# 响应系统(4~6章)

## 4.1 响应式数据与副作用函数

副作用函数指的是会产生副作用的函数（如：修改输入参数、修改全局变量、IO 操作及状态改变），具体代码如下：

```javascript
// 除 effect 以外，任意函数都可能读取或修改 body 的内容，所以执行 effect 就直接或间接的影响了其他函数的执行，这样的函数被称为副作用函数
function effect() {
  document.body.innerText = 'Hello World';
}
```

假设在副作用函数中读取了某一个对象的属性，当这个对象的属性再次变化时，我们希望副作用函数可以重新执行，如果能实现这个目标，那么这个对象就是响应式数据：

```javascript
const obj = { text: 'Hello World' }
function effect () {
	document.body.innerText = obj.text;
}
```

## 4.2 响应式数据的基本实现

将 obj 变成响应式数据有一个必须满足的要求，就是监听属性的读取和设置操作：

* 副作用函数执行：触发 obj.text 的读取操作；
* 修改 text 属性值：触发 obj.text 的设置操作；

当 obj.text 触发读取操作时将 effect 存储到”桶“（依赖收集），当 obj.text 触发设置操作时，将 effect 从”桶“中取出执行即可。

要实现对象属性读取和设置的拦截，在 ES2015 之前只能通过 Object.defineProperty 函数实现，在 ES2015+中可以使用 Proxy 代理对象实现，分别代表了 Vue.js2 和 Vue.js3 的实现方案：

```javascript
// mini-vue3.js
const bucket = new Set();

function reactive(data, fn) {
    return new Proxy(data, {
        get(target, key) {
            bucket.add(effect);
            return target[key];
        },
        set(target, key, value) {
            target[key] = value;
            bucket.forEach(fn => fn());
            return true;
        }
    })
}
```

调用编写好的 reactive 函数，将 data 变成响应式数据 obj：

```javascript
const data = { text: 'Hello World!' }

// 将 data 变成响应式对象
const obj = reactive(data)

function effect() {
    document.body.innerHTML = obj.text;
}

effect();

setTimeout(() => {
    obj.text = 'Hello Vuejs3';
},1000)
```

由于目前 effect 是硬编码到 reactive 函数中，这样当副作用函数名称修改后，框架将无法正常工作，使得当前的实现非常不灵活。

## 4.3 设计一个完善的响应系统

为了移出硬编码副作用函数的方式，这里引入了注册副作用函数的机制，通过全局变量 `__activeEffect` 来存储副作用函数，在框架中编写 effect 函数，此函数用于注册应用中使用到的副作用函数：

```javascript
// mini-vue3.js
const bucket = new Set();

// 储存副作用函数
window.__activeEffect = undefined;

// 注册副作用函数的函数
function effect(fn) {
    window.__activeEffect = fn;
    fn();
}

function reactive(data) {
    return new Proxy(data, {
        get(target, key) {
            if(window.__activeEffect) {
                bucket.add(window.__activeEffect);
            }
            return target[key];
        },
        set(target, key, value) {
            target[key] = value;
            bucket.forEach(fn => fn());
            return true;
        }
    })
}
```

在应用中使用时，为 effect 传入一个设置 body 内容的匿名函数，并首次执行，在 1 秒钟后由于修改 obj.text 的内容而触发 set 拦截再次执行：

```javascript
const data = { text: 'Hello World!' }

// 将 data 变成响应式对象
const obj = reactive(data)

effect(() => {
    document.body.innerHTML = obj.text;
});

setTimeout(() => {
    obj.text = 'Hello Vuejs3';
},1000)
```

在匿名的副作用函数中目前仅读取了 `obj.text`，但如果在 setTimeout 中尝试为 obj 添加一个新的属性并赋值，将会看到 effect 函数并执行了两次：

```javascript
const data = { text: 'Hello World!' }

// 将 data 变成响应式对象
const obj = reactive(data)

effect(() => {
    console.log('effect')
    document.body.innerHTML = obj.text;
});

setTimeout(() => {
    obj.nokey = 'Hello Vuejs3';
},1000)
```

这是因为目前仅用 Set 结构来存储的副作用函数，而副作用函数并没有和具体的目标字段建立连接，所以造成了这个现象，所以接下来主要就是建立原始对象（target）、字段名（key）和副作用函数（effectFn）,下图是几种可见的对应关系：

```mermaid
graph LR;
target --> key --> effectFn;
```

```mermaid
graph LR;
target --> key;
key --> effectFn1;
key --> effectFn2;
```

```mermaid
graph LR;
target --> key1;
target --> key2;
key1--> effectFn;
key2--> effectFn;
```

```mermaid
graph LR;
target --> key1;
target --> key2;
key1--> effectFn1;
key2--> effectFn2;
```



了解的所有可见的对应关系，现在定义一个 WeakMap 结构来存储对应关系，如下图：

```mermaid
graph LR;
WeakMap --key--> target;
WeakMap --value--> Map;

Map --key--> prop;
Map --value--> Set;

Set --> effectFn1;
Set --> effectFn2;
Set --> effectFn3;
```

按照图示结修改 Proxy 内部代码，利用新的 bucket 完善对应关系：

```javascript
// mini-vue3.js
const bucket = new WeakMap();

window.__activeEffect = undefined;

function effect(fn) {
    window.__activeEffect = fn;
    fn();
}

// 将 fn 添加到 target 中 key 下的的副作用函数集合
function track(target, key) {
    if (!window.__activeEffect) return;

    let map = bucket.get(target);
    if (!map) {
        map = new Map();
        bucket.set(target, map);
    }

    let effects = map.get(key);
    if (!effects) {
        effects = new Set();
        map.set(key, effects);
    }

    effects.add(window.__activeEffect);
}

// 调用 target 中指定 key 下的所有副作用函数
function trigger(target, key) {
    const map = bucket.get(target);
    if (!map) return;
    const effects = map.get(key);
    effects?.forEach(effect => effect());
}

function reactive(data) {
    return new Proxy(data, {
        get(target, key) {
            track(target, key);
            return target[key];
        },
        set(target, key, value) {
            target[key] = value;
            trigger(target, key);
        }
    })
}
```

这里解释一下使用 WeakMap 的原因，WeakMap 的特点是它的 Key 在底层规范为弱引用，相比于 Map 中 Key 为强应用来说，更利于垃圾回收机制进行回收，正如下面这段代码所示，当 10，11 行执行完毕后，由于 fn1 任作为 Key 被 Map 引用，所以无法回收，而 fn2 虽然作为 weak 的 key，但由于弱引用的设计，并不影响垃圾回收，那么如果使用 Map 做桶的结构，那么就有可能因为应用中已经不需要引用 target 了，但 target 不会被回收，造成内存泄漏：

```javascript
const map = new Map();
const weak = new WeakMap();

const fn1 = { text: 'Hello Fn1' };
const fn2 = { text: 'Hello Fn2' };

map.set(fn1, fn1)
weak.set(fn2, fn2)

console.log("map has fn1: ", map.has(fn1)) // true
console.log("weak has fn2: ", weak.has(fn2)) // true

console.log("map: ", map); // Map(1) { { text: 'Hello Fn1' } => { text: 'Hello Fn1' } }
console.log("weak: ", weak); // WeakMap { <items unknown> }
```

## 4.4 分支切换与cleanup

在下图的副作用函数中当 obj.ok 的值发生变化时，代码执行的分支将发生变化，这就是分支切换。

```                                                                                                                                                    JavaScript
const data = { ok: true, text: 'Hello World!' }

// 将 data 变成响应式对象
const obj = reactive(data)

effect(() => {
    document.body.innerHTML = obj.ok ? obj.text : 'not';
});
```

由于 obj.ok 初始值为 true，所以当副作用函数执行时，会触发 ok 和 text 两个属性的读取操作，此时所建立的连接如下图：

```mermaid
graph LR;
WeakMap --key--> data;
data --key--> ok;
ok --value--> 01[Set] ---> effectFn;

data --key--> text;
text --value--> 02[Set] ---> effectFn;
```

分支切换可能会产生遗留的副作用函数，正如下面的代码所示：当 1 秒过后将 obj.ok 切换为 false，再过 1 秒将 obj.text 更新为 'Hello Vuejs3'，页面并不会发生变化（obj.text 不会读取），但副作用函数仍被执行，因为产生了遗留的副作用函数。

```javascript
const data = { ok: true, text: 'Hello World!' }

// 将 data 变成响应式对象
const obj = reactive(data)

effect(() => {
    console.log('effect')
    document.body.innerHTML = obj.ok ? obj.text : 'not';
});

setTimeout(() => {
    obj.ok = false;
}, 1000)

setTimeout(() => {
    obj.text = 'Hello Vuejs3';
}, 1000)
```

解决遗留副作用函数思路就是在执行副作用函数的之前删除依赖关系，在执行副作用函数之后重新建立依赖关系。要将副作用函数从所有已知的依赖集合中移除，就需要明确哪些依赖集合中包含了它，因此需要重新设计副作用函数：

```javascript
function effect(fn) {
    const effectFn = () => {
        window.__activeEffect = effectFn;
        fn();
    }
    effectFn.deps = []; // 存储与此副作用函数相关联的依赖集合
    effectFn();
}
```

```javascript
function track(target, key) {
    if (!window.__activeEffect) return;

    let map = bucket.get(target);
    if (!map) {
        map = new Map();
        bucket.set(target, map);
    }

    let effects = map.get(key);
    if (!effects) {
        effects = new Set();
        map.set(key, effects);
    }

    effects.add(window.__activeEffect);
  	// 完成依赖反向收集
    window.__activeEffect.deps.push(effects);
}
```



```mermaid
graph LR;
WeakMap --key--> data;
data --key--> ok;
ok --value--> 01[Set] ---> effectFn;
effectFn ---> 01[Set];

data --key--> text;
text --value--> 02[Set] ---> effectFn;

effectFn ---> 02[Set];
```

接着增加清空依赖集合的方法，并在 effectFn 中优先执行清空依赖集合：

```javascript
function cleanup(effectFn) {
    effectFn.deps.forEach(effect => {
        effect.delete(effectFn);
    });
    effectFn.deps.lenght = 0;
}

function effect(fn) {
    const effectFn = () => {
        cleanup(effectFn); // 清空依赖集合
        window.__activeEffect = effectFn;
        fn();
    }
    effectFn.deps = []; // 存储与此副作用函数相关联的依赖集合
    effectFn();
}

function trigger(target, key) {
    const map = bucket.get(target);
    if (!map) return;
    const effects = map.get(key);
    const effectsToRun = new Set(effects);
    effectsToRun.forEach(effect => effect()); // 解决由于删除 Set 集合的元素造成 forEach 进入死循环
    // effects?.forEach(effect => effect());
}
```

PS：当使用 forEach 遍历 Set 集合，由于被访问过的值被删除后重新添加到集合，如果 forEach 没有结束，那么这个值将会被再次访问，造成死循环；

## 4.5 嵌套的 effect 与 effect 栈



## 4.6 避免无限递归循环

## 4.7 调度执行

## 4.8 计算属性 computed 与 lazy

## 4.9 watch 的实现原理



## 非原始值的响应式方案



## 原始值的响应式方案

