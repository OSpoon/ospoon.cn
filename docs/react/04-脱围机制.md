# 脱围机制 Escape Hatches

脱围机制是 React 提供给开发者一种在必要时刻绕过框架直接使用较低级别的 API 或原生 DOM API 进行底层操作的机制。例如：操作浏览器 API 实现输入框聚集，或者存储和操作 DOM 元素等。

## Ref



## Effect



## Hook





## 使用 ref 引用值

当你需要在组件中存储某些信息，但这些信息不用于渲染逻辑时，可以使用 `ref`：

```javascript
import { useRef } from 'react';
const ref = useRef(0);
console.log(ref.current); // 打印当前 ref 的值，同时 current 属性也支持修改
```

### 使用 ref 的场景

* 存储 timeout ID
* 存储和操作 DOM元素
* 存储不被用来计算 JSX 的其他对象

### 两个使用原则：

1. 将 `ref` 视为脱围机制，如果应用逻辑和数据流大量依赖 `ref`，需考虑是否用 `state` 重构；
2. 不要在渲染过程中去读或写入 `ref.current`，因 React 无法及时感知其变化，造成组件行为难以预测。

### 实现可暂停的秒表

如下代码是 [react.dev](react.dev) 提供的基础代码，在代码中使用 `useState` 定义了表示起始时间和当前时间`State`，并使用 `setInterval()` 每隔 10 毫秒更新一次当前时间。

```jsx
import { useState } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      setNow(Date.now);
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>时间过去了：{secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>开始</button>
    </>
  );
}
```

在基础代码上通过 `ref` 记录 interval ID并在点击停止按钮时将指定的 ID 的 interval 清除，以便停止 `now` state 更新，达到停止秒表的效果：

```jsx
import { useRef, useState } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
	// 声明 intervalRef 记录 interval ID 以便根据 ID 清除 interval
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    // 清除已有的 interval
    clearInterval(intervalRef.current);
    // 记录新的 interval ID
    intervalRef.current = setInterval(() => {
      setNow(Date.now);
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>时间过去了：{secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>开始</button>
      <button onClick={handleStop}>停止</button>
    </>
  );
}
```

### ref 和 state 对比

|          | ref                                              | state                                                        |
| :------- | :----------------------------------------------- | :----------------------------------------------------------- |
| 声明方式 | `useRef(initialValue)`                           | `useState(initialValue)`                                     |
| 返回类型 | `{ current: initialValue }`                      | `[value, setValue]`                                          |
| 重新渲染 | 更新时不触发重新渲染                             | 更新时触发重新渲染                                           |
| 是否可变 | 可变-可以在渲染过程之外修改和更新 `current` 的值 | 不可变-必须使用 state 的设置函数修改 state 变量，从而重新排队渲染 |
| 读取自由 | 禁止在渲染期间读取（或写入） `current` 值        | 可以随时读取 state。但每次渲染都有自己不变的 state 快照      |

## 使用 ref 操作 DOM



## 使用 Effect 同步



## 