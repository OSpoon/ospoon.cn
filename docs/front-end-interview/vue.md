# Vue 面试

## v-if 和 v-for 那个优先级更高？

首先可以肯定的是在 vue2 和 vue3 在文档中都明确的表示我们不应该将 v-if 和 v-for 同时使用在同一个元素。其中 vue2 和 vue3 中 v-if 和 v-for 的优先级是不同的。

在 vue2 中 v-for 的优先级要高于 v-if，当同一个元素同时绑定 v-for 和 v-if 时，每次循环都将运行一次 if 判断，这种机制对于要过滤列表中的项目来说还是十分有用的，但是对于需要隐藏列表的情况来说就导致了无用的遍历和多余的 if 判断。

在 vue3 中 v-if 的优先级又调成成高于 v-for，所以同样是在同一个元素绑定 v-for 和 v-if，依旧是要过滤列表中的项目的场景，但此时将抛出属性为 undefined 的错误，因为 v-if 的优先级高于 v-for ，所以根本获取不到项目中的属性。此时就需要把 v-if 提取到外层容器或`template`上。

## 简述 Vue 的生命周期以及每个阶段做的事情



## v-model 双向绑定的使用和原理



## 子组件是否可以直接改变父组件的数据

按照文档所述，当我们使用 Prop 在父子组件进行传参时，应该遵守单向绑定原则（单向数据流），当父组件状态发生变更时所有的子组件中的 props 都会被更新为最新的值，如果意外的在子组件修改父组件的状态，那应用的数据流将变得难以理解，同时 Vue 会在控制台抛出对应的警告信息（提示 prop 是只读的）。

一般来有两个场景可能会迫使你修改 prop 数据：

1. 子组件在读取 prop 值后需要作为局部数据使用，那么应该考虑重新定义一个变量并将 prop 值赋值到新的变量。
2. 子组件在读取 prop 值后需要做进一步的转换，那么应该考虑使用计算属性。

如果实际开发时确实需要改变父组件属性，那么应该在子组件通过 emit 派发事件到父组件，让父组件主动变更。

## Computed 和 watch 的区别以及选择

## vue-lodaer 是什么？有什么用？

vue-loader 是用于处理单文件组件（SFC）的一个 webpack loader；

因为有了 vue-loader 的加持，我们才可以在项目中 .vue 文件格式来编写 vue 组件，SFC 组件通常由 template、script 和 style 组成，结合其他的一些 loader 还可以支持在 style 中编写 sass、less 等样式，还可以在 script 中编写 TS。

webpack 会在打包时以 loader 的方式调用 vue-loader；

vue-loader 被执行时，他会对 SFC 中的每个template、script、style 做单独的 loader 链处理。最后将这些单独的块组装成最终的组件模块。

在 webpack 中如果你试图通过异步的形式为 webpack 添加 loader，是一件危险的事情，它会打破 webpack 中 loader 的加载顺序，导致必要的 loader 无法执行，如果确实有这样的必要可以在 webpack 插件的 beforeRun 钩子函数中执行，这是钩子函数中最早支持异步任务的位置。

  ## 写过自定义指令吗？有哪些场景？

自定义指令主要是用来完成一些可复用的底层 DOM 操作，自定义指令由包含类似生命周期的钩子作为属性组成，如果在自定义指令时仅需要用到 `mounted` 和 `updated` 钩子，则可以用一个函数来定义。注册全局自定义指令时可以通过 `app.directive()` 函数，如果是局部使用要分两个情况，在 <script setup> 中默认将 `v` 开头的变量视为之定义指令，反之需要将指令显示的申明到 `directives` 选项中。

我在项目中为了规范表单输入项的限制条件，我往往会通过维护统一的自定义指令组来实现，在 updated 中拿到指令所绑定的 DOM，首先通过类型来确定获取到的是 input 相关类型，因为在 elementUI 或 antdv 的表单组件中，有添加前后缀的情况，会与普通的 input 组件结构有所区别，接着利用正则过滤掉不符合规则的内容，再将得到的内容赋值给 DOM，其中由于内容的删减会造成光标的偏移，所以需要再过滤前后分别记录和移动光标到合适的位置。

## Composition API 与 Options API 有什么不同

